# //////////////////////////////////////////////////////////////////////////
- docker:
# //////////////////////////////////////////////////////////////////////////
  # use given docker context (assume ssh has already connected) ?
  # - docker context use $DCTX

  # ////////////////////////////////////////////////////////////////////////////
  - make:
  # ////////////////////////////////////////////////////////////////////////////

    # start the docker image build service
    - docker-compose-wrapper build --force-rm ${DOCKER_COMPOSE_SERVICE}

    # ignore any build errors (in case there are no dangling images)
    - docker rmi -f $(docker images -f "dangling=true" -q) 2&1> /dev/null

  # ////////////////////////////////////////////////////////////////////////////
  - container:
  # ////////////////////////////////////////////////////////////////////////////

    - shell:
      - start:
        # always create the default network if does not exist
        - echo "Docker network subnet is $LOCAL_NETWORK_SUBNET"
        - echo "Docker network ip range is $LOCAL_NETWORK_IP_RANGE"
        # - docker network create -d bridge robots --subnet=$LOCAL_NETWORK_SUBNET --ip-range=$LOCAL_NETWORK_IP_RANGE || true

        # start the docker create container service
        - docker-compose-wrapper -p project-${DOCKER_COMPOSE_SERVICE} up --force-recreate -d ${DOCKER_COMPOSE_SERVICE}

      # stopping containers
      - stop:
        # - docker stop $(docker ps -a -q)
        - echo "stopping... $(docker ps --format '{{.Names}}' | grep "^${DOCKER_CONTAINER}")"
        - docker ps --format '{{.Names}}' | grep "^${DOCKER_CONTAINER}" | awk '{print $1}' | xargs -I {} docker stop {}

      # removing containers
      - rm:
        # - docker rm -f $(docker ps -a -q)
        - echo "removing... $(docker ps -a --format '{{.Names}}' | grep "^${DOCKER_CONTAINER}")"
        - docker ps -a --format '{{.Names}}' | grep "^${DOCKER_CONTAINER}" | awk '{print $1}' | xargs -I {} docker rm -f {}
