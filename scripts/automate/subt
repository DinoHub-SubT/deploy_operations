#!/usr/bin/env bash

# load header helper functions
. "$SUBT_PATH/operations/scripts/.header.bash"
. "$SUBT_PATH/operations/scripts/automate/.header.bash"
. "$SUBT_PATH/operations/scripts/automate/cmpl/completion.bash"

# //////////////////////////////////////////////////////////////////////////////
# @brief some pre-defined shell env configuration settings
# //////////////////////////////////////////////////////////////////////////////
if [ ! -z "$ZSH_NAME" ]; then
  # bash-completion under zsh
  autoload bashcompinit
  bashcompinit

  autoload -Uz compinit
  compinit

  # remove fuzzy search in zsh-completion
  zstyle ":completion:*" matcher-list ''
fi

# //////////////////////////////////////////////////////////////////////////////
# @brief evaluate which subcommand to switch and execute
# //////////////////////////////////////////////////////////////////////////////
__subt_git_execute() {
  local _opts=""
  chk_flag -p $@ && _opts="$_opts -p"
  chk_flag -v $@ && _opts="$_opts -v"

  # echo "try to execute? $@"
  # remove the argument flag & its value (append to the end of the git deployer call)
  while chk_flag -e $@; do
    local idx=$(get_idx -e $@)
    ((idx++))
     _opts="$_opts -e ${@[idx + 1]}"
    set -- "${@:1:$idx-1}" "${@:$idx+2}"
  done

  # get the given git action command
  local _git_action_cmd=${@[1]}
  # apply the general git action scripts
  if chk_flag status $@ || chk_flag sync $@  || chk_flag add $@; then
    shift 1
    ($GL_BIN_AUTOMATE_DIR/cmpl/git.bash $@)
  elif chk_flag help $@; then
    __git_help
  # apply the deployer action scripts
  else
    shift 1 # shift 'git'
    _run_deployer "$@" "$_opts"
#     shift 2
#     for _subrepo in "$@"; do
#       # ignore the preview or verbose flags, added seperately
#       chk_flag -p $_subrepo || chk_flag -v $_subrepo && continue
#       # apply the deployer git actions
#       _run_deployer "git.$_subrepo.$_git_action_cmd" "$_opts"
#       # ignore all catkin files, if pulling the latest updates
#       if  chk_flag clone $_git_action_cmd || chk_flag reset $_git_action_cmd ||
#           chk_flag pull $_git_action_cmd; then
#         _run_deployer "git.$_subrepo.ignore" "$_opts"
#       fi
#     done
  fi
}

# //////////////////////////////////////////////////////////////////////////////
# @brief evaluate which subcommand to switch and execute
# //////////////////////////////////////////////////////////////////////////////
__subt_robots_execute() {
  # terraform azure setup
  if chk_flag terraform $@; then
    shift 2 # shift the 'cloud terraform' tokens

    # go through all terraform files, check if filename suffix is a given arguments
    for filename in $SUBT_OPERATIONS_PATH/azurebooks/scripts/*.sh; do
      # get the type of terraform script call (find script by filename suffix)
      filename=$(basename $filename)
      filename="${filename%.*}"
      suffix="${filename##*_}"
      # execute the terraform script if script found in input
      if chk_flag $suffix $@; then
        (subtf_${@[1]}.sh ${@:2})
      fi
    done
  fi
}

# //////////////////////////////////////////////////////////////////////////////
# @brief evaluate which subcommand to switch and execute
# //////////////////////////////////////////////////////////////////////////////
__subt_cloud_execute() {
  # ansible azure install
  if chk_flag ansible $@; then
    shift 2 # shift the 'git', 'info' tokens
    (subtani_install.sh $@)
  # terraform azure setup
  elif chk_flag terraform $@; then
    shift 2 # shift the 'cloud terraform' tokens

    # go through all terraform files, check if filename suffix is a given arguments
    for filename in $SUBT_OPERATIONS_PATH/azurebooks/scripts/*.sh; do
      # get the type of terraform script call (find script by filename suffix)
      filename=$(basename $filename)
      filename="${filename%.*}"
      suffix="${filename##*_}"
      # execute the terraform script if script found in input
      if chk_flag $suffix $@; then
        (subtf_${@[1]}.sh ${@:2})
      fi
    done
  fi
}

# //////////////////////////////////////////////////////////////////////////////
# @brief evaluate which subcommand to switch and execute
# //////////////////////////////////////////////////////////////////////////////
__subt_tools_execute() {
  # verify given the correct tool input script names
  if chk_flag ssh $@ || chk_flag teamviewer $@ || chk_flag rdp $@ || chk_flag snapshot $@; then
    shift
    (subtu_avail_${@[1]} ${@:2})
  fi
}

# //////////////////////////////////////////////////////////////////////////////
# @brief 'git subt' wrapper entrypoint
# //////////////////////////////////////////////////////////////////////////////
subt() {
  # get the current directory
  local __pwd=$(pwd)

  # execute actual git command (filter any 'git subt' subcommands)
  if chk_nth_flag 1 "git" "$@"; then
    # execute git subt main entrypoint
    __subt_git_execute $@
    # command git "$@"

  # execute 'git subt' subcommand
  elif chk_nth_flag 1 "deployer" "$@"; then
    shift 1 # shift 'deployer'
    _run_deployer "$@"

  elif chk_nth_flag 1 "robots" "$@"; then
    __subt_robots_execute $@

  elif chk_nth_flag 1 "cloud" "$@"; then
    __subt_cloud_execute $@

  elif chk_nth_flag 1 "tools" "$@"; then
    __subt_tools_execute $@

  elif chk_nth_flag 1 "update" "$@"; then
    cd $SUBT_PATH
    ./install-deployer.bash --uninstall
    ./install-deployer.bash --install
    text "Please source your bash or zsh rc: 'source ~/.bashrc'"

  elif chk_flag --help $@ || chk_flag help $@ || chk_flag -h $@; then
    __subt_help
    cd $__pwd
    return 0
  fi

  # return to path of call
  cd $__pwd
}

# //////////////////////////////////////////////////////////////////////////////
# enable tab autocompletion
# 'nosort' option does not work with bash <= 4.4.20 (https://lists.defectivebydesign.org/archive/html/bug-bash/2017-05/msg00034.html)
# //////////////////////////////////////////////////////////////////////////////
complete -o nospace -o nosort -F _ac_subt_completion subt
